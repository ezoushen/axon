# Deployment Configuration Example
# Copy this file to your product root as 'deploy.config.yml' and customize
#
# IMPORTANT: All deployment scripts run from your LOCAL MACHINE
# and SSH to both Application Server and System Server to execute commands.

# Product Information
product:
  name: "my-product"
  description: "My Application"

# AWS Configuration
aws:
  profile: "default"
  region: "ap-northeast-1"
  account_id: "123456789012"
  ecr_repository: "my-product"

# Server Configuration
servers:
  # System Server (nginx + SSL)
  system:
    host: "system.example.com"           # System Server IP or hostname
    user: "ubuntu"                       # SSH user (must exist, SSH key required)
    ssh_key: "~/.ssh/system_server_key"  # SSH private key (must exist)

  # Application Server (Docker containers)
  application:
    host: "app.example.com"                  # Application Server public IP/hostname (for SSH)
    private_ip: "10.0.1.10"                  # Private IP within VPC (for nginx upstream)
    user: "ubuntu"                           # SSH user (must exist, SSH key required)
    ssh_key: "~/.ssh/app_server_key"         # SSH private key (must exist)
    deploy_path: "/home/ubuntu/apps/my-product" # Deployment directory on Application Server

# Environment Configurations
environments:
  # Production Environment
  production:
    # Port is auto-assigned by Docker (no manual configuration needed)
    # nginx upstream: Auto-generated as /etc/nginx/upstreams/my-product-production.conf
    # nginx backend:  Auto-generated as my_product_production_backend
    env_file: ".env.production"
    image_tag: "production"

  # Staging Environment
  staging:
    # Port is auto-assigned by Docker (no manual configuration needed)
    # nginx upstream: Auto-generated as /etc/nginx/upstreams/my-product-staging.conf
    # nginx backend:  Auto-generated as my_product_staging_backend
    env_file: ".env.staging"
    image_tag: "staging"

# Health Check Configuration
health_check:
  endpoint: "/api/health"                    # Health check endpoint

  # Docker container health check settings (used by Docker daemon)
  interval: "30s"                            # How often Docker checks
  timeout: "10s"                             # Max time to wait for response
  retries: 3                                 # Failed checks before unhealthy
  start_period: "40s"                        # Grace period on startup

  # Deployment verification (script polls Docker's health status)
  max_retries: 30                            # Max polling attempts
  retry_interval: 2                          # Seconds between polls

# Deployment Options
deployment:
  connection_drain_time: 5
  enable_auto_rollback: true
  keep_old_images: 3
  log_retention: 30

# Docker Configuration
docker:
  # Image configuration (template variables: ${AWS_ACCOUNT_ID}, ${AWS_REGION}, ${ECR_REPOSITORY}, ${IMAGE_TAG})
  image_template: "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}:${IMAGE_TAG}"

  # Container runtime configuration
  restart_policy: "unless-stopped"

  # Network configuration
  # Template variables: ${PRODUCT_NAME}, ${ENVIRONMENT}
  network_name: "${PRODUCT_NAME}-${ENVIRONMENT}-network"
  network_driver: "bridge"

  # Common environment variables for all environments
  # These are set in the container, separate from .env files
  common_env_vars:
    NODE_ENV: "production"
    PORT: "3000"

  # Extra hosts mapping (allows container to access host services)
  extra_hosts:
    - "host.docker.internal:host-gateway"

  # Logging configuration
  logging:
    driver: "json-file"
    max_size: "10m"
    max_file: 3
