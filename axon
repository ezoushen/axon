#!/bin/bash
# AXON - Zero-Downtime Deployment Orchestration
#
# Usage: axon <command> [environment] [options]
# Example: axon build production --skip-git
# Example: axon run staging --config custom.yml

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Script directory (resolve symlinks for Homebrew compatibility)
# We need to follow symlinks to find the real script location for lib files
SOURCE="${BASH_SOURCE[0]}"
while [[ -L "$SOURCE" ]]; do
    DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    # If SOURCE is relative, resolve it relative to the symlink's directory
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"

# For product root (where config files live), use current working directory
# This allows axon to work as both a git submodule (deploy/) and Homebrew install
PRODUCT_ROOT="$PWD"

# Source command parser library
source "$SCRIPT_DIR/lib/command-parser.sh"

# Source context manager library
source "$SCRIPT_DIR/lib/context-manager.sh"

# Global variables
COMMAND=""
ENVIRONMENT=""
CONFIG_FILE="axon.config.yml"
CONFIG_FILE_EXPLICIT=""  # Set when -c flag is used
CONTEXT_OVERRIDE=""       # Set when --context flag is used
PROJECT_ROOT="$PWD"       # Will be updated by context resolution
CONTEXT_MODE="local"      # local|explicit|context:name|error
VERBOSE=false
DRY_RUN=false

# Export variables that child scripts need to see
export VERBOSE
export DRY_RUN
export PROJECT_ROOT
export CONFIG_FILE

# Command-specific variables
SKIP_GIT=false
GIT_SHA=""
FORCE=false
NO_CACHE=false
FOLLOW=false
LINES=""
SINCE=""
TIMEOUT=""
STRICT=false
INSTALL_TARGET=""
AUTO_INSTALL=false
INTERACTIVE=false
OUTPUT_FILE=""
# --all flags for environment commands
STATUS_ALL=false
HEALTH_ALL=false
LOGS_ALL=false
RESTART_ALL=false
DELETE_ALL=false
# Status command flags
STATUS_DETAILED=false
STATUS_CONFIG=false
STATUS_HEALTH=false

#==============================================================================
# Helper Functions
#==============================================================================

# Print verbose message
verbose() {
    if [ "$VERBOSE" = true ]; then
        echo -e "${BLUE}[VERBOSE]${NC} $1"
    fi
}

# Print dry-run message
dry_run() {
    if [ "$DRY_RUN" = true ]; then
        echo -e "${YELLOW}[DRY-RUN]${NC} Would execute: $1"
    fi
}

# Execute command (respects dry-run)
execute() {
    local cmd="$1"
    dry_run "$cmd"

    if [ "$DRY_RUN" = false ]; then
        eval "$cmd"
    fi
}

# Make config path absolute
make_config_absolute() {
    if [[ "$CONFIG_FILE" != /* ]]; then
        CONFIG_FILE="${PRODUCT_ROOT}/${CONFIG_FILE}"
    fi
}

# Validate config file exists
validate_config_file() {
    make_config_absolute

    if [ ! -f "$CONFIG_FILE" ]; then
        echo -e "${RED}Error: Config file not found: $CONFIG_FILE${NC}"
        exit 1
    fi
}

#==============================================================================
# Command Implementations
#==============================================================================

# Build command
cmd_build() {
    verbose "Executing build command for environment: $ENVIRONMENT"
    validate_config_file

    local build_args=("--config" "$CONFIG_FILE" "$ENVIRONMENT")

    if [ "$SKIP_GIT" = true ]; then
        build_args+=("--skip-git")
    elif [ -n "$GIT_SHA" ]; then
        build_args+=("$GIT_SHA")
    fi

    if [ "$NO_CACHE" = true ]; then
        build_args+=("--no-cache")
    fi

    verbose "Calling build.sh with args: ${build_args[*]}"
    execute "\"$SCRIPT_DIR/tools/build.sh\" ${build_args[*]}"
}

# Push command
cmd_push() {
    verbose "Executing push command for environment: $ENVIRONMENT"
    validate_config_file

    local push_args=("--config" "$CONFIG_FILE" "$ENVIRONMENT")

    if [ -n "$GIT_SHA" ]; then
        push_args+=("$GIT_SHA")
    fi

    verbose "Calling push.sh with args: ${push_args[*]}"
    execute "\"$SCRIPT_DIR/tools/push.sh\" ${push_args[*]}"
}

# Deploy command
cmd_deploy() {
    verbose "Executing deploy command for environment: $ENVIRONMENT"
    validate_config_file

    local deploy_args=("--config" "$CONFIG_FILE")

    if [ "$FORCE" = true ]; then
        deploy_args+=("--force")
    fi

    deploy_args+=("$ENVIRONMENT")

    verbose "Calling deploy.sh with args: ${deploy_args[*]}"
    execute "\"$SCRIPT_DIR/tools/deploy.sh\" ${deploy_args[*]}"
}

# Run command (full pipeline)
cmd_run() {
    verbose "Executing full pipeline for environment: $ENVIRONMENT"
    validate_config_file

    echo -e "${CYAN}===========================================================${NC}"
    echo -e "${CYAN}AXON - Full Deployment Pipeline: ${ENVIRONMENT}${NC}"
    echo -e "${CYAN}Build → Push to ECR → Zero-Downtime Deploy${NC}"
    echo -e "${CYAN}Config: ${CONFIG_FILE}${NC}"
    echo -e "${CYAN}===========================================================${NC}"
    echo ""

    # Step 1: Build
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BLUE}Step 1/3: Build Docker Image${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""

    local build_args=("--config" "$CONFIG_FILE" "$ENVIRONMENT")
    if [ "$SKIP_GIT" = true ]; then
        build_args+=("--skip-git")
    elif [ -n "$GIT_SHA" ]; then
        build_args+=("$GIT_SHA")
    fi

    # Capture build output to extract auto-detected git SHA
    BUILD_OUTPUT=$("$SCRIPT_DIR/tools/build.sh" "${build_args[@]}" 2>&1)
    BUILD_EXIT_CODE=$?

    # Display build output
    echo "$BUILD_OUTPUT"

    if [ $BUILD_EXIT_CODE -ne 0 ]; then
        echo -e "${RED}✗ Build failed!${NC}"
        exit 1
    fi

    # Extract auto-detected git SHA if present
    if [ -z "$GIT_SHA" ] && [ "$SKIP_GIT" = false ]; then
        DETECTED_SHA=$(echo "$BUILD_OUTPUT" | grep "GIT_SHA_DETECTED=" | cut -d'=' -f2)
        if [ -n "$DETECTED_SHA" ]; then
            GIT_SHA="$DETECTED_SHA"
            verbose "Captured git SHA from build: $GIT_SHA"
        fi
    fi

    echo ""
    echo -e "${GREEN}✓ Build completed successfully!${NC}"
    echo ""

    # Step 2: Push
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BLUE}Step 2/3: Push to AWS ECR${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""

    local push_args=("--config" "$CONFIG_FILE" "$ENVIRONMENT")
    if [ -n "$GIT_SHA" ]; then
        push_args+=("$GIT_SHA")
    fi

    "$SCRIPT_DIR/tools/push.sh" "${push_args[@]}"

    if [ $? -ne 0 ]; then
        echo -e "${RED}✗ Push failed!${NC}"
        exit 1
    fi

    echo ""
    echo -e "${GREEN}✓ Push completed successfully!${NC}"
    echo ""

    # Step 3: Deploy
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BLUE}Step 3/3: Zero-Downtime Deployment${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""

    local deploy_args=("--config" "$CONFIG_FILE")
    if [ "$FORCE" = true ]; then
        deploy_args+=("--force")
    fi
    deploy_args+=("$ENVIRONMENT")

    "$SCRIPT_DIR/tools/deploy.sh" "${deploy_args[@]}"

    if [ $? -ne 0 ]; then
        echo -e "${RED}✗ Deployment failed!${NC}"
        exit 1
    fi

    # Success!
    echo ""
    echo -e "${GREEN}===========================================================${NC}"
    echo -e "${GREEN}✓ Full deployment pipeline completed successfully!${NC}"
    echo -e "${GREEN}===========================================================${NC}"
    echo ""

    echo -e "${CYAN}Summary:${NC}"
    echo -e "  Config:      ${YELLOW}${CONFIG_FILE}${NC}"
    echo -e "  Build:       ${GREEN}✓ Completed${NC}"
    if [ "$SKIP_GIT" = true ]; then
        echo -e "  Git SHA:     ${YELLOW}Skipped${NC}"
    elif [ -n "$GIT_SHA" ]; then
        echo -e "  Git SHA:     ${YELLOW}${GIT_SHA}${NC}"
    else
        echo -e "  Git SHA:     ${GREEN}Auto-detected${NC}"
    fi
    echo -e "  Push:        ${GREEN}✓ Completed${NC}"
    echo -e "  Deployment:  ${GREEN}✓ Completed${NC}"
    echo -e "  Environment: ${YELLOW}${ENVIRONMENT}${NC}"
    echo ""
}

# Build and push command
cmd_build_and_push() {
    verbose "Executing build-and-push for environment: $ENVIRONMENT"
    validate_config_file

    echo -e "${CYAN}===========================================================${NC}"
    echo -e "${CYAN}AXON - Build and Push: ${ENVIRONMENT}${NC}"
    echo -e "${CYAN}Build → Push to ECR${NC}"
    echo -e "${CYAN}Config: ${CONFIG_FILE}${NC}"
    echo -e "${CYAN}===========================================================${NC}"
    echo ""

    # Build
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BLUE}Step 1/2: Build Docker Image${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""

    cmd_build

    echo ""
    echo -e "${GREEN}✓ Build completed!${NC}"
    echo ""

    # Push
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BLUE}Step 2/2: Push to AWS ECR${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""

    cmd_push

    echo ""
    echo -e "${GREEN}===========================================================${NC}"
    echo -e "${GREEN}✓ Build and push completed successfully!${NC}"
    echo -e "${GREEN}===========================================================${NC}"
    echo ""
}

# Install command
cmd_install() {
    verbose "Executing install command for target: $INSTALL_TARGET"

    # If no target specified, install on all servers
    if [ -z "$INSTALL_TARGET" ]; then
        echo -e "${CYAN}Installing AXON on all servers...${NC}"
        echo ""

        # Install local first
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${BLUE}Step 1/3: Installing on Local Machine${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""

        INSTALL_TARGET="local"
        cmd_install

        echo ""
        echo -e "${GREEN}✓ Local machine installation completed${NC}"
        echo ""

        # Install app-server
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${BLUE}Step 2/3: Installing on Application Server${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""

        INSTALL_TARGET="app-server"
        cmd_install

        echo ""
        echo -e "${GREEN}✓ Application Server installation completed${NC}"
        echo ""

        # Install system-server
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${BLUE}Step 3/3: Installing on System Server${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""

        INSTALL_TARGET="system-server"
        cmd_install

        echo ""
        echo -e "${GREEN}===========================================================${NC}"
        echo -e "${GREEN}✓ AXON installation completed on all servers!${NC}"
        echo -e "${GREEN}===========================================================${NC}"
        echo ""
        return 0
    fi

    case "$INSTALL_TARGET" in
        local)
            verbose "Installing on local machine"
            local install_args=()
            if [ "$AUTO_INSTALL" = true ]; then
                install_args+=("--auto-install")
            fi

            verbose "Calling setup-local-machine.sh with args: ${install_args[*]}"
            execute "\"$SCRIPT_DIR/setup/setup-local-machine.sh\" ${install_args[*]}"
            ;;

        app-server)
            verbose "Installing on Application Server"
            validate_config_file

            local install_args=("--config" "$CONFIG_FILE")

            verbose "Calling setup-application-server.sh with args: ${install_args[*]}"
            execute "\"$SCRIPT_DIR/setup/setup-application-server.sh\" ${install_args[*]}"
            ;;

        system-server)
            verbose "Installing on System Server"
            validate_config_file

            local install_args=("--config" "$CONFIG_FILE")

            verbose "Calling setup-system-server.sh with args: ${install_args[*]}"
            execute "\"$SCRIPT_DIR/setup/setup-system-server.sh\" ${install_args[*]}"
            ;;

        *)
            echo -e "${RED}Error: Unknown install target: ${INSTALL_TARGET}${NC}"
            echo ""
            echo "Available targets:"
            echo "  (none)        - Install on all servers"
            echo "  local         - Install on local machine"
            echo "  app-server    - Install on Application Server"
            echo "  system-server - Install on System Server"
            echo ""
            echo "Run 'axon install --help' for more information"
            exit 1
            ;;
    esac
}

# Uninstall command
cmd_uninstall() {
    verbose "Executing uninstall command for target: $INSTALL_TARGET"

    # If no target specified, uninstall from all servers (reverse order)
    if [ -z "$INSTALL_TARGET" ]; then
        echo -e "${CYAN}Uninstalling AXON from all servers...${NC}"
        echo ""

        # Uninstall system-server first (reverse order)
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${BLUE}Step 1/3: Uninstalling from System Server${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""

        INSTALL_TARGET="system-server"
        cmd_uninstall

        echo ""
        echo -e "${GREEN}✓ System Server uninstallation completed${NC}"
        echo ""

        # Uninstall app-server
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${BLUE}Step 2/3: Uninstalling from Application Server${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""

        INSTALL_TARGET="app-server"
        cmd_uninstall

        echo ""
        echo -e "${GREEN}✓ Application Server uninstallation completed${NC}"
        echo ""

        # Uninstall local last
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${BLUE}Step 3/3: Uninstalling from Local Machine${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""

        INSTALL_TARGET="local"
        cmd_uninstall

        echo ""
        echo -e "${GREEN}===========================================================${NC}"
        echo -e "${GREEN}✓ AXON uninstallation completed from all servers!${NC}"
        echo -e "${GREEN}===========================================================${NC}"
        echo ""
        return 0
    fi

    case "$INSTALL_TARGET" in
        local)
            verbose "Uninstalling from local machine"
            local uninstall_args=()
            if [ "$FORCE" = true ]; then
                uninstall_args+=("--force")
            fi

            verbose "Calling uninstall-local-machine.sh with args: ${uninstall_args[*]}"
            execute "\"$SCRIPT_DIR/setup/uninstall-local-machine.sh\" ${uninstall_args[*]}"
            ;;

        app-server)
            verbose "Uninstalling from Application Server"
            validate_config_file

            local uninstall_args=("--config" "$CONFIG_FILE")
            if [ "$FORCE" = true ]; then
                uninstall_args+=("--force")
            fi

            verbose "Calling uninstall-application-server.sh with args: ${uninstall_args[*]}"
            execute "\"$SCRIPT_DIR/setup/uninstall-application-server.sh\" ${uninstall_args[*]}"
            ;;

        system-server)
            verbose "Uninstalling from System Server"
            validate_config_file

            local uninstall_args=("--config" "$CONFIG_FILE")
            if [ "$FORCE" = true ]; then
                uninstall_args+=("--force")
            fi

            verbose "Calling uninstall-system-server.sh with args: ${uninstall_args[*]}"
            execute "\"$SCRIPT_DIR/setup/uninstall-system-server.sh\" ${uninstall_args[*]}"
            ;;

        *)
            echo -e "${RED}Error: Unknown uninstall target: ${INSTALL_TARGET}${NC}"
            echo ""
            echo "Available targets:"
            echo "  (none)        - Uninstall from all servers"
            echo "  local         - Uninstall from local machine"
            echo "  app-server    - Uninstall from Application Server"
            echo "  system-server - Uninstall from System Server"
            echo ""
            echo "Run 'axon uninstall --help' for more information"
            exit 1
            ;;
    esac
}

# Status command
cmd_status() {
    if [ "$STATUS_ALL" = true ]; then
        verbose "Executing status command for all environments"
    else
        verbose "Executing status command for environment: $ENVIRONMENT"
    fi
    validate_config_file

    local status_args=("--config" "$CONFIG_FILE")

    if [ "$STATUS_ALL" = true ]; then
        status_args+=("--all")
    elif [ -n "$ENVIRONMENT" ]; then
        status_args+=("$ENVIRONMENT")
    fi

    if [ "$STATUS_DETAILED" = true ]; then
        status_args+=("--detailed")
    fi

    if [ "$STATUS_CONFIG" = true ]; then
        status_args+=("--configuration")
    fi

    if [ "$STATUS_HEALTH" = true ]; then
        status_args+=("--health")
    fi

    verbose "Calling status.sh with args: ${status_args[*]}"
    execute "\"$SCRIPT_DIR/tools/status.sh\" ${status_args[*]}"
}

# Logs command
cmd_logs() {
    if [ "$LOGS_ALL" = true ]; then
        verbose "Executing logs command for all environments"
    else
        verbose "Executing logs command for environment: $ENVIRONMENT"
    fi
    validate_config_file

    local logs_args=("--config" "$CONFIG_FILE")

    if [ "$LOGS_ALL" = true ]; then
        logs_args+=("--all")
    else
        logs_args+=("$ENVIRONMENT")
    fi

    if [ "$FOLLOW" = true ]; then
        logs_args+=("--follow")
    fi

    if [ -n "$LINES" ]; then
        logs_args+=("--lines" "$LINES")
    fi

    if [ -n "$SINCE" ]; then
        logs_args+=("--since" "$SINCE")
    fi

    verbose "Calling logs.sh with args: ${logs_args[*]}"
    execute "\"$SCRIPT_DIR/tools/logs.sh\" ${logs_args[*]}"
}

# Restart command
cmd_restart() {
    if [ "$RESTART_ALL" = true ]; then
        verbose "Executing restart command for all environments"
    else
        verbose "Executing restart command for environment: $ENVIRONMENT"
    fi
    validate_config_file

    local restart_args=("--config" "$CONFIG_FILE")

    if [ "$RESTART_ALL" = true ]; then
        restart_args+=("--all")
        if [ "$FORCE" = true ]; then
            restart_args+=("--force")
        fi
    else
        restart_args+=("$ENVIRONMENT")
    fi

    verbose "Calling restart.sh with args: ${restart_args[*]}"
    execute "\"$SCRIPT_DIR/tools/restart.sh\" ${restart_args[*]}"
}

# Delete command
cmd_delete() {
    if [ "$DELETE_ALL" = true ]; then
        verbose "Executing delete command for all environments"
    else
        verbose "Executing delete command for environment: $ENVIRONMENT"
    fi
    validate_config_file

    local delete_args=("--config" "$CONFIG_FILE")
    if [ "$FORCE" = true ]; then
        delete_args+=("--force")
    fi
    if [ "$DELETE_ALL" = true ]; then
        delete_args+=("--all")
    else
        delete_args+=("$ENVIRONMENT")
    fi

    verbose "Calling delete.sh with args: ${delete_args[*]}"
    execute "\"$SCRIPT_DIR/tools/delete.sh\" ${delete_args[*]}"
}

# Health command
cmd_health() {
    if [ "$HEALTH_ALL" = true ]; then
        verbose "Executing health check command for all environments"
    else
        verbose "Executing health check command for environment: $ENVIRONMENT"
    fi
    validate_config_file

    local health_args=("--config" "$CONFIG_FILE")

    if [ "$HEALTH_ALL" = true ]; then
        health_args+=("--all")
    elif [ -n "$ENVIRONMENT" ]; then
        health_args+=("$ENVIRONMENT")
    fi

    verbose "Calling health-check.sh with args: ${health_args[*]}"
    execute "\"$SCRIPT_DIR/tools/health-check.sh\" ${health_args[*]}"
}

#==============================================================================
# Argument Parsing
#==============================================================================

# Check if no arguments provided
if [ $# -eq 0 ]; then
    show_help
    exit 0
fi

# Check for global --help or --version
if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
    show_help
    exit 0
fi

if [ "$1" = "--version" ]; then
    VERSION_FILE="$SCRIPT_DIR/VERSION"
    if [ -f "$VERSION_FILE" ]; then
        VERSION=$(cat "$VERSION_FILE" | tr -d '[:space:]')
        echo "AXON version $VERSION"
    else
        echo "AXON version unknown (VERSION file not found)"
    fi
    exit 0
fi

# Parse global flags that can come before the command
while [[ $# -gt 0 ]]; do
    case $1 in
        --context)
            CONTEXT_OVERRIDE="$2"
            shift 2
            ;;
        -c|--config)
            CONFIG_FILE="$2"
            CONFIG_FILE_EXPLICIT="$2"
            shift 2
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        *)
            # Not a global flag, assume it's the command
            break
            ;;
    esac
done

# First argument should be command
COMMAND="$1"
shift

# Validate command
if ! validate_command "$COMMAND"; then
    echo -e "${RED}Error: Unknown command: ${COMMAND}${NC}"
    echo ""
    echo "Run 'axon --help' to see available commands"
    exit 1
fi

# Check for command-specific help
if [ $# -gt 0 ] && ([ "$1" = "--help" ] || [ "$1" = "-h" ]); then
    show_command_help "$COMMAND"
    exit 0
fi

# Special handling for context command - pass all args directly to handler
if [ "$COMMAND" = "context" ]; then
    source "$SCRIPT_DIR/tools/context.sh"
    handle_context_command "$@"
    exit $?
fi

# Special handling for config command - pass all args directly to handler
if [ "$COMMAND" = "config" ]; then
    source "$SCRIPT_DIR/tools/config.sh"
    handle_config_command "$@"
    exit $?
fi

# Special handling for env command - pass all args directly to handler
if [ "$COMMAND" = "env" ]; then
    source "$SCRIPT_DIR/tools/env.sh"
    handle_env_command "$@"
    exit $?
fi

# Parse arguments based on command
# Note: Some commands require environment, others don't
# Global flags (-c, --context, -v) are already parsed above
while [[ $# -gt 0 ]]; do
    case $1 in
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --skip-git)
            SKIP_GIT=true
            shift
            ;;
        --sha)
            GIT_SHA="$2"
            shift 2
            ;;
        -f|--force)
            FORCE=true
            shift
            ;;
        --no-cache)
            NO_CACHE=true
            shift
            ;;
        --follow)
            FOLLOW=true
            shift
            ;;
        -n|--lines)
            LINES="$2"
            shift 2
            ;;
        --since)
            SINCE="$2"
            shift 2
            ;;
        --timeout)
            TIMEOUT="$2"
            shift 2
            ;;
        --strict)
            STRICT=true
            shift
            ;;
        --auto-install)
            AUTO_INSTALL=true
            shift
            ;;
        -i|--interactive)
            INTERACTIVE=true
            shift
            ;;
        -f|--file)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        --detailed|--inspect)
            STATUS_DETAILED=true
            shift
            ;;
        --configuration|--env)
            STATUS_CONFIG=true
            shift
            ;;
        --health)
            STATUS_HEALTH=true
            shift
            ;;
        --all)
            # Set appropriate flag based on command
            case "$COMMAND" in
                status)
                    STATUS_ALL=true
                    ;;
                health)
                    HEALTH_ALL=true
                    ;;
                logs)
                    LOGS_ALL=true
                    ;;
                restart)
                    RESTART_ALL=true
                    ;;
                delete)
                    DELETE_ALL=true
                    ;;
                *)
                    echo -e "${RED}Error: --all flag is not supported for command: ${COMMAND}${NC}"
                    exit 1
                    ;;
            esac
            shift
            ;;
        -h|--help)
            show_command_help "$COMMAND"
            exit 0
            ;;
        -*)
            echo -e "${RED}Error: Unknown option: $1${NC}"
            echo "Run 'axon $COMMAND --help' for usage information"
            exit 1
            ;;
        *)
            # Positional argument (environment or install/uninstall target)
            if [ "$COMMAND" = "install" ] || [ "$COMMAND" = "uninstall" ]; then
                # For install/uninstall commands, first positional is the target (optional)
                if [ -z "$INSTALL_TARGET" ]; then
                    INSTALL_TARGET="$1"
                else
                    echo -e "${RED}Error: Too many positional arguments${NC}"
                    echo "Run 'axon $COMMAND --help' for usage information"
                    exit 1
                fi
            else
                # For other commands, it's the environment
                if [ -z "$ENVIRONMENT" ]; then
                    ENVIRONMENT="$1"
                else
                    echo -e "${RED}Error: Too many positional arguments${NC}"
                    echo "Run 'axon $COMMAND --help' for usage information"
                    exit 1
                fi
            fi
            shift
            ;;
    esac
done

# Validate environment is provided for commands that require it
if command_requires_env "$COMMAND"; then
    if [ -z "$ENVIRONMENT" ]; then
        echo -e "${RED}Error: Environment parameter required for command: ${COMMAND}${NC}"
        echo "Run 'axon $COMMAND --help' for usage information"
        exit 1
    fi
fi

# Special validation for commands that support --all flag
case "$COMMAND" in
    status)
        if [ "$STATUS_ALL" = false ] && [ -z "$ENVIRONMENT" ]; then
            echo -e "${RED}Error: Environment parameter required for status command (or use --all)${NC}"
            echo "Run 'axon status --help' for usage information"
            exit 1
        fi
        ;;
    health)
        if [ "$HEALTH_ALL" = false ] && [ -z "$ENVIRONMENT" ]; then
            echo -e "${RED}Error: Environment parameter required for health command (or use --all)${NC}"
            echo "Run 'axon health --help' for usage information"
            exit 1
        fi
        ;;
    logs)
        if [ "$LOGS_ALL" = false ] && [ -z "$ENVIRONMENT" ]; then
            echo -e "${RED}Error: Environment parameter required for logs command (or use --all)${NC}"
            echo "Run 'axon logs --help' for usage information"
            exit 1
        fi
        ;;
    restart)
        if [ "$RESTART_ALL" = false ] && [ -z "$ENVIRONMENT" ]; then
            echo -e "${RED}Error: Environment parameter required for restart command (or use --all)${NC}"
            echo "Run 'axon restart --help' for usage information"
            exit 1
        fi
        ;;
    delete)
        if [ "$DELETE_ALL" = false ] && [ -z "$ENVIRONMENT" ]; then
            echo -e "${RED}Error: Environment parameter required for delete command (or use --all)${NC}"
            echo "Run 'axon delete --help' for usage information"
            exit 1
        fi
        ;;
esac

#==============================================================================
# Context Resolution
#==============================================================================

# Resolve config and project root using context system
# Skip for commands that don't need config (context, config, env, setup local, --version, --help)
SKIP_CONTEXT_RESOLUTION=false
case "$COMMAND" in
    context)
        SKIP_CONTEXT_RESOLUTION=true
        ;;
    config)
        SKIP_CONTEXT_RESOLUTION=true
        ;;
    env)
        SKIP_CONTEXT_RESOLUTION=true
        ;;
    install|uninstall)
        if [ "$INSTALL_TARGET" = "local" ]; then
            SKIP_CONTEXT_RESOLUTION=true
        fi
        ;;
esac

if [ "$SKIP_CONTEXT_RESOLUTION" = false ]; then
    verbose "Resolving config and project root..."

    # Use resolve_config from context-manager.sh
    # Temporarily disable set -e so command substitution failures don't exit the script
    set +e
    RESOLVED=$(resolve_config "$CONFIG_FILE_EXPLICIT" "$CONTEXT_OVERRIDE" 2>/dev/null)
    RESOLVE_EXIT=$?
    set -e

    if [ $RESOLVE_EXIT -ne 0 ]; then
        # Error occurred during resolution
        ERROR_MSG=$(echo "$RESOLVED" | grep "^error:" | cut -d':' -f2-)
        HINT_MSG=$(echo "$RESOLVED" | grep "^hint:" | cut -d':' -f2-)

        echo -e "${RED}Error:${ERROR_MSG}${NC}" >&2
        if [ -n "$HINT_MSG" ]; then
            echo -e "${YELLOW}Hint:${HINT_MSG}${NC}" >&2
        fi
        echo "" >&2
        echo "Options:" >&2
        echo "  - Work with an existing context: axon context list" >&2
        echo "  - Create a new context: axon context add <name>" >&2
        echo "  - Create config in this directory: axon config init" >&2
        exit 1
    fi

    # Extract resolved values
    CONTEXT_MODE=$(echo "$RESOLVED" | grep "^mode:" | cut -d' ' -f2-)
    CONFIG_FILE=$(echo "$RESOLVED" | grep "^config:" | cut -d' ' -f2-)
    PROJECT_ROOT=$(echo "$RESOLVED" | grep "^project_root:" | cut -d' ' -f2-)
    CONTEXT_NAME=$(echo "$RESOLVED" | grep "^context:" | cut -d' ' -f2-)

    # Export for child scripts
    export PROJECT_ROOT
    export CONFIG_FILE
    export CONTEXT_MODE
    export CONTEXT_NAME

    # If using context mode, cd to project root (Option A from design)
    if [ "$CONTEXT_MODE" = "context" ] && [ -n "$PROJECT_ROOT" ] && [ "$PROJECT_ROOT" != "$PWD" ]; then
        verbose "Switching to project root: $PROJECT_ROOT"
        cd "$PROJECT_ROOT" || {
            echo -e "${RED}Error: Cannot access project root: $PROJECT_ROOT${NC}"
            exit 1
        }
    fi

    verbose "Config resolved via: $CONTEXT_MODE"
    verbose "Config file: $CONFIG_FILE"
    verbose "Project root: $PROJECT_ROOT"
fi

#==============================================================================
# Command Execution
#==============================================================================

verbose "Command: $COMMAND"
verbose "Environment: $ENVIRONMENT"
verbose "Config: $CONFIG_FILE"
verbose "Dry-run: $DRY_RUN"

# Execute the command
case "$COMMAND" in
    build)
        cmd_build
        ;;
    push)
        cmd_push
        ;;
    deploy)
        cmd_deploy
        ;;
    run)
        cmd_run
        ;;
    build-and-push)
        cmd_build_and_push
        ;;
    status)
        cmd_status
        ;;
    logs)
        cmd_logs
        ;;
    restart)
        cmd_restart
        ;;
    delete)
        cmd_delete
        ;;
    health)
        cmd_health
        ;;
    install)
        cmd_install
        ;;
    uninstall)
        cmd_uninstall
        ;;
    *)
        echo -e "${RED}Error: Command not implemented: ${COMMAND}${NC}"
        exit 1
        ;;
esac

exit 0
